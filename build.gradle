plugins {
    id 'org.unbroken-dome.test-sets' version '1.3.2'
    id 'com.github.johnrengelman.shadow' version '1.2.4'
}

group 'gofish'
version '1.0-SNAPSHOT'

task wrapper(type: Wrapper) {
    gradleVersion = '3.3'
    distributionUrl = "https://services.gradle.org/distributions/gradle-$gradleVersion-all.zip"
}

apply plugin: 'build-dashboard'

check.mustRunAfter buildDashboard
check.dependsOn buildDashboard

reporting {
    baseDir "reports"
}

ext { vertxVersion = "3.3.3"; junitVersion = "4.12"; mockitoVersion = "2.+" }

configure (subprojects) { project ->
    apply plugin: 'java'
    apply plugin: 'application'
    apply plugin: 'jacoco'
    apply plugin: 'pmd'
    apply plugin: 'findbugs'
    apply plugin: 'com.github.johnrengelman.shadow'
    apply plugin: 'org.unbroken-dome.test-sets'

    mainClassName = 'io.vertx.core.Launcher'

    repositories { mavenLocal(); mavenCentral() }

    dependencies {
        compile ("io.vertx:vertx-core:${vertxVersion}")
        compile ("io.vertx:vertx-hazelcast:${vertxVersion}")
        compile ("io.vertx:vertx-rx-java:${vertxVersion}")
        compile ("io.vertx:vertx-service-discovery:${vertxVersion}")
        compile ("io.vertx:vertx-service-proxy:${vertxVersion}")
        compile ("biz.paluch.logging:logstash-gelf:1.10.0")

        compileOnly ('io.vertx:vertx-codegen:3.3.3')

        testCompile ("io.vertx:vertx-unit:${vertxVersion}")
        testCompile ("junit:junit:${junitVersion}")
        testCompile ("org.mockito:mockito-core:${mockitoVersion}")
    }

    testSets { testIT }

    assemble.dependsOn shadowJar
    check.dependsOn testIT // Ensure both test and testIT run under check

    task annotationProcessing(type: JavaCompile, group: 'build', description: "Generates the Vert.x proxies") {
        source = sourceSets.main.java
        classpath = configurations.compile + configurations.compileOnly
        destinationDir = project.file('src/main/generated')
        options.compilerArgs = [
                "-proc:only",
                "-processor", "io.vertx.codegen.CodeGenProcessor",
                "-AoutputDirectory=${project.projectDir}/src/main"
        ]
    }

    task jacocoTestITReport(type: JacocoReport) {
        executionData project.tasks.testIT

        sourceDirectories = project.files(sourceSets.main.allSource.srcDirs)
        classDirectories = project.sourceSets.main.output

        def reportDir = project.reporting.file("jacoco/testIT/html")
        reports {
            html.destination = reportDir
        }
    }

    test {
        outputs.upToDateWhen { false }
        finalizedBy tasks.jacocoTestReport
        jacoco {
            append = false
            destinationFile = new File(project.buildDir, 'jacoco/test.exec')
        }
    }

    testIT {
        outputs.upToDateWhen { false }
        mustRunAfter test
        finalizedBy tasks.jacocoTestITReport
        jacoco {
            append = false
            destinationFile = new File(project.buildDir, 'jacoco/testIT.exec')
        }
    }

    shadowJar {
        classifier = null
        mergeServiceFiles {
            include 'META-INF/services/io.vertx.core.spi.VerticleFactory'
        }
    }

    tasks.withType(Test) {
        reports {
            junitXml.enabled = false
            html.enabled = true
        }
    }

    tasks.withType(JacocoReport) {
        afterEvaluate {
            classDirectories = files(classDirectories.files.collect {
                fileTree(dir: it, exclude: ['**/rxjava', '**/*VertxProxyHandler*', '**/*VertxEBProxy*'])
            })
        }

        reports {
            xml.enabled = false
            html.enabled = true
        }
    }

    tasks.withType(Pmd) {
        ignoreFailures = true

        // Exclude all auto-generated code
        excludes += ['**/rxjava', '**/*VertxProxyHandler**', '**/*VertxEBProxy**']

        reports {
            xml.enabled = false
            html.enabled = true
        }
    }
}